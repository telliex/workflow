(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{180:function(t,e,i){t.exports=i.p+"assets/img/theTestingTrophy-01.ee5dea20.png"},181:function(t,e,i){t.exports=i.p+"assets/img/theTestingTrophy-02.d29e5c74.png"},236:function(t,e,i){"use strict";i.r(e);var _=[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"测试策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#测试策略","aria-hidden":"true"}},[this._v("#")]),this._v(" 测试策略")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"测试需要花费太多时间和精力"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#测试需要花费太多时间和精力","aria-hidden":"true"}},[this._v("#")]),this._v(" 测试需要花费太多时间和精力??")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("没时间。 我知道，你已经很忙了。")]),this._v(" "),e("li",[this._v("没有明显的投资回报率。 我知道，你不确定测试到底能带来什么。")]),this._v(" "),e("li",[this._v("没有_办法_测试一切。 我知道，大多数测试都是所谓的_点点点……_。这感觉就像浪费时间，我们都喜欢开发新功能，而不只是对着旧功能“点点点……”。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("你所开发的软件终将被测试。如果不是由你自己发现，那么就是由你的用户发现（💥Bug）。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"已需要不同的测试策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#已需要不同的测试策略","aria-hidden":"true"}},[this._v("#")]),this._v(" 已需要不同的测试策略")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("因此，我们需要有策略性地"),e("code",[this._v("根据收益-成本的原则，考虑项目的实际情况和痛点来定制测试策略")]),this._v("：比如三方依赖多的项目可以多写些契约测试，业务场景多、复杂或经常回归的场景可以多写些端到端测试，等。但不论如何，整个测试奖杯体系中，你还是应该拥有更多低层次的单元测试，因为它们成本相对最低，运行速度最快（通常是毫秒级别），而对单元的保护价值相对更大。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"测试奖杯：软件测试的分层策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#测试奖杯：软件测试的分层策略","aria-hidden":"true"}},[this._v("#")]),this._v(" 测试奖杯：软件测试的分层策略")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:i(180),alt:"测试奖杯"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("使用静态类型系统和 linter 来捕获拼写或语法之类的基本错误。")]),this._v(" "),e("li",[this._v("编写有效单元测试 需要特别针对于应用的某些关键行为或功能。=> TDD")]),this._v(" "),e("li",[this._v("编写集成测试 以确保 Web 应用各模块之间能够正常协调工作。")]),this._v(" "),e("li",[this._v("创建端到端（e2e）功能测试 对关键路径进行自动化点击操作，而不是等到最终用户来发现问题。=> BDD")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"vue-应用测试的测试策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-应用测试的测试策略","aria-hidden":"true"}},[this._v("#")]),this._v(" Vue 应用测试的测试策略")])},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("table",[i("thead",[i("tr",[i("th",{staticStyle:{"text-align":"left"}},[t._v("架构层级")]),t._v(" "),i("th",{staticStyle:{"text-align":"left"}},[t._v("测试内容")]),t._v(" "),i("th",{staticStyle:{"text-align":"left"}},[t._v("测试策略")]),t._v(" "),i("th",{staticStyle:{"text-align":"left"}},[t._v("解释")])])]),t._v(" "),i("tbody",[i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("action 层")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("1. 是否获取了正确的参数"),i("br"),t._v(" 2. 是否正确地调用了 API"),i("br"),t._v(" 3. 是否使用了正确的返回值存取回 Vuex 中"),i("br"),t._v(" 4. 业务分支逻辑"),i("br"),t._v(" 5. 异常逻辑")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("这五个业务点建议 100% 覆盖")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("这个层级主要包含前述 5 大方面的业务逻辑，进行测试很有重构价值")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("mutation 层")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("是否正确完成计算")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("有逻辑的 mutation 要求 100%覆盖率")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("这个层级输入输出明确，又包含业务计算，非常适合单元测试")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("getter 层")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("是否正确完成计算")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("有逻辑的 getter 要求 100%覆盖率")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("这个层级输入输出明确，又包含业务计算，非常适合单元测试")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("component 层")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("是否渲染了正确的组件")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("1. 组件的分支渲染逻辑要求100%覆盖"),i("br"),t._v(" 2. 交互事件的调用参数一般要求100%覆盖"),i("br"),t._v(" 3. 被 connect 过的组件不测")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("这个层级最为复杂，还是以「代价最低，收益最高」为指导原则进行")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("UI 层")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("组件是否渲染了正确的样式")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("1. 纯 UI 不测"),i("br"),t._v(" 2. CSS 不测")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("这个层级以我目前理解来说测试较难稳定，成本又较高")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("utils 层")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("各种辅助工具函数")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("没有副作用的必须 100% 覆盖")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}})])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"component-的测试标准"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#component-的测试标准","aria-hidden":"true"}},[this._v("#")]),this._v(" Component 的测试标准")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("展示型业务组件")]),this._v(" "),e("li",[this._v("容器型业务组件")]),this._v(" "),e("li",[this._v("通用 UI 组件")]),this._v(" "),e("li",[this._v("功能型组件")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("总结一下，其实每种组件都要测渲染分支和事件调用，跟组件类型根本没必然的关联…"),e("br"),this._v(" "),e("img",{attrs:{src:i(181),alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[this._v("#")]),this._v(" 参考")])}],a=i(0),s=Object(a.a)({},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),i("p",[t._v("事实上，没有人有时间。但是，无论如何：")]),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),i("p",[t._v("对于一个自动化测试策略，应该包含种类不同、关注点不同的测试，比如关注单元的单元测试、关注集成和契约的集成测试和契约测试、关注业务验收点的端到端测试等。正常来说，我们会受到资源的限制，无法应用所有层级的测试，效果也未必最佳。")]),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),i("p",[t._v("测试奖杯（Testing Trophy）是一种自下而上的 Web 应用测试策略。其实这是在说我们需要编写_恰到好处的_测试，给予团队足够的信心 —— 正确的测试，而_不是_仅仅追求达到100％的测试覆盖率而已。")]),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),i("p",[t._v("一个常见的 Vue 应用会包括这么几个层面：组件、数据管理、Vuex、副作用等等，对于不同的项目应该有一定的适应性。Vue + Vuex 架构中的不同元素有不同的特点，因此即便是单元测试，我们也会有针对性的测试策略")]),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),i("p",[t._v("组件测试其实是前端测试中实践最多，但各方看法最不统一的地方，这也是前后端在谈论单元测试时最大的分歧所在。Vue 组件是一个高度自治的单元，从分类上来看，它大概有这么几类：")]),t._v(" "),t._m(12),t._v(" "),i("p",[t._v("对于 Vue 组件测什么不测什么有一些判断标准：除去功能型组件，其他类型的组件一般是以渲染出一个语法树 render() 为终点的，它描述了页面的 UI 内容、结构、样式和一些逻辑 component(props) => UI。内容、结构和样式，比起测试，直接在页面上调试反馈效果更好。测也不是不行，但都难免有不稳定的成本在；逻辑这块，有一测的价值，但需要控制好依赖。综合上面提到的测试原则进行考虑，建议是：两测两不测。")]),t._v(" "),i("ul",[i("li",[t._v("组件分支渲染逻辑必须测")]),t._v(" "),i("li",[t._v("事件调用和参数传递一般要测")]),t._v(" "),i("li",[t._v("连接 vuex 的高阶 "),i("a",{attrs:{href:"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0",target:"_blank",rel:"noopener noreferrer"}},[t._v("SMART 组件"),i("OutboundLink")],1),t._v("不测")]),t._v(" "),i("li",[t._v("渲染出来的 UI 不在单元测试层级测")])]),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),i("p",[t._v("-"),i("a",{attrs:{href:"https://blog.jimmylv.info/2019-05-08-vue-application-unit-test-strategy-and-practice-05-testing-trophy/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue 应用单元测试的策略与实践 05 - 测试奖杯策略"),i("OutboundLink")],1)])])},_,!1,null,null,null);e.default=s.exports}}]);